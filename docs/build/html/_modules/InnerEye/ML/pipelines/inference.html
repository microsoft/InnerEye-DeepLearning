<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>InnerEye.ML.pipelines.inference &mdash; InnerEye-DeepLearning 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> InnerEye-DeepLearning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/innereye_deeplearning.html">InnerEye-DeepLearning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/WSL.html">How to use the Windows Subsystem for Linux (WSL2) for development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/environment.html">Set up InnerEye-DeepLearning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/setting_up_aml.html">How to setup Azure Machine Learning for InnerEye</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/creating_dataset.html">Dataset Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/building_models.html">Building Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/sample_tasks.html">Sample Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/debugging_and_monitoring.html">Debugging and Monitoring Jobs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Further reading for contributors</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/pull_requests.html">Suggested Workflow for Pull Requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/testing.html">Pytest and testing on CPU and GPU machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/hello_world_model.html">Training a Hello World segmentation model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/deploy_on_aml.html">Model Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/bring_your_own_model.html">Bring Your Own PyTorch Lightning Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/fastmri.html">Working with FastMRI models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/innereye_as_submodule.html">Using the InnerEye code as a git submodule of your project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/model_diagnostics.html">Model Diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/move_model.html">Move a model to other workspace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/self_supervised_models.html">Training of self-supervised models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/CHANGELOG.html">Changelog</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation (ðŸš§ Work In Progress ðŸš§)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/api/ML/index.html">Machine learning</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">InnerEye-DeepLearning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>InnerEye.ML.pipelines.inference</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for InnerEye.ML.pipelines.inference</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ------------------------------------------------------------------------------------------</span>
<span class="c1">#  Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c1">#  Licensed under the MIT License (MIT). See LICENSE in the repo root for license information.</span>
<span class="c1">#  ------------------------------------------------------------------------------------------</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torchio</span> <span class="k">as</span> <span class="nn">tio</span>

<span class="kn">from</span> <span class="nn">InnerEye.Common.type_annotations</span> <span class="kn">import</span> <span class="n">TupleFloat3</span>
<span class="kn">from</span> <span class="nn">InnerEye.ML</span> <span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">InnerEye.ML.config</span> <span class="kn">import</span> <span class="n">SegmentationModelBase</span>
<span class="kn">from</span> <span class="nn">InnerEye.ML.lightning_helpers</span> <span class="kn">import</span> <span class="n">load_from_checkpoint_and_adjust_for_inference</span>
<span class="kn">from</span> <span class="nn">InnerEye.ML.lightning_models</span> <span class="kn">import</span> <span class="n">SegmentationLightning</span>
<span class="kn">from</span> <span class="nn">InnerEye.ML.model_config_base</span> <span class="kn">import</span> <span class="n">ModelConfigBase</span>
<span class="kn">from</span> <span class="nn">InnerEye.ML.utils</span> <span class="kn">import</span> <span class="n">image_util</span><span class="p">,</span> <span class="n">ml_util</span>
<span class="kn">from</span> <span class="nn">InnerEye.ML.utils.image_util</span> <span class="kn">import</span> <span class="n">compute_uncertainty_map_from_posteriors</span><span class="p">,</span> <span class="n">gaussian_smooth_posteriors</span><span class="p">,</span> \
    <span class="n">posteriors_to_segmentation</span>


<div class="viewcode-block" id="InferencePipelineBase"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipelineBase">[docs]</a><span class="k">class</span> <span class="nc">InferencePipelineBase</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for all inference pipelines.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfigBase</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span> <span class="o">=</span> <span class="n">model_config</span></div>


<div class="viewcode-block" id="FullImageInferencePipelineBase"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.FullImageInferencePipelineBase">[docs]</a><span class="k">class</span> <span class="nc">FullImageInferencePipelineBase</span><span class="p">(</span><span class="n">InferencePipelineBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base Class for full image inference intended to be inherited by inference pipelines</span>
<span class="sd">    that can perform full image prediction</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_config</span><span class="p">:</span> <span class="n">SegmentationModelBase</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model_config</span><span class="p">)</span>

<div class="viewcode-block" id="FullImageInferencePipelineBase.predict_and_post_process_whole_image"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.FullImageInferencePipelineBase.predict_and_post_process_whole_image">[docs]</a>    <span class="k">def</span> <span class="nf">predict_and_post_process_whole_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_channels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                             <span class="n">voxel_spacing_mm</span><span class="p">:</span> <span class="n">TupleFloat3</span><span class="p">,</span>
                                             <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                             <span class="n">patient_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict_whole_image</span><span class="p">(</span><span class="n">image_channels</span><span class="p">,</span> <span class="n">voxel_spacing_mm</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">patient_id</span><span class="p">))</span></div>

<div class="viewcode-block" id="FullImageInferencePipelineBase.predict_whole_image"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.FullImageInferencePipelineBase.predict_whole_image">[docs]</a>    <span class="k">def</span> <span class="nf">predict_whole_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_channels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">voxel_spacing_mm</span><span class="p">:</span> <span class="n">TupleFloat3</span><span class="p">,</span>
                            <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">patient_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Full image inference capability must be implemented by concrete classes&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="FullImageInferencePipelineBase.post_process"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.FullImageInferencePipelineBase.post_process">[docs]</a>    <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform connected component analysis to update segmentation with largest</span>
<span class="sd">        connected component based on the configurations</span>
<span class="sd">        :param results: inference results to post-process</span>
<span class="sd">        :return: post-processed version of results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">posterior_smoothing_mm</span><span class="p">:</span>
            <span class="n">posteriors</span> <span class="o">=</span> <span class="n">gaussian_smooth_posteriors</span><span class="p">(</span>
                <span class="n">posteriors</span><span class="o">=</span><span class="n">results</span><span class="o">.</span><span class="n">posteriors</span><span class="p">,</span>
                <span class="n">kernel_size_mm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">posterior_smoothing_mm</span><span class="p">,</span>
                <span class="n">voxel_spacing_mm</span><span class="o">=</span><span class="n">results</span><span class="o">.</span><span class="n">voxel_spacing_mm</span>
            <span class="p">)</span>

            <span class="n">results</span> <span class="o">=</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">(</span>
                <span class="n">patient_id</span><span class="o">=</span><span class="n">results</span><span class="o">.</span><span class="n">patient_id</span><span class="p">,</span>
                <span class="n">posteriors</span><span class="o">=</span><span class="n">posteriors</span><span class="p">,</span>
                <span class="n">segmentation</span><span class="o">=</span><span class="n">posteriors_to_segmentation</span><span class="p">(</span><span class="n">posteriors</span><span class="p">),</span>
                <span class="n">voxel_spacing_mm</span><span class="o">=</span><span class="n">results</span><span class="o">.</span><span class="n">voxel_spacing_mm</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">summed_probability_rules</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">disable_extra_postprocessing</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="p">,</span> <span class="n">SegmentationModelBase</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">with_new_segmentation</span><span class="p">(</span>
                <span class="n">image_util</span><span class="o">.</span><span class="n">apply_summed_probability_rules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">posteriors</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">segmentation</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">largest_connected_component_foreground_classes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get indices for classes to restrict</span>
            <span class="n">restrict_class_indices_and_thresholds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">class_and_index_with_background</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">name2</span><span class="p">,</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">largest_connected_component_foreground_classes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name2</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                        <span class="n">restrict_class_indices_and_thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">with_new_segmentation</span><span class="p">(</span>
                <span class="n">image_util</span><span class="o">.</span><span class="n">extract_largest_foreground_connected_component</span><span class="p">(</span>
                    <span class="n">multi_label_array</span><span class="o">=</span><span class="n">results</span><span class="o">.</span><span class="n">segmentation</span><span class="p">,</span>
                    <span class="c1"># mypy gets confused below because List is invariant. Sequence is covariant</span>
                    <span class="c1"># but does not allow &quot;append&quot;.</span>
                    <span class="n">restrictions</span><span class="o">=</span><span class="n">restrict_class_indices_and_thresholds</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">slice_exclusion_rules</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">disable_extra_postprocessing</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">with_new_segmentation</span><span class="p">(</span>
                <span class="n">image_util</span><span class="o">.</span><span class="n">apply_slice_exclusion_rules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">segmentation</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="InferencePipeline"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipeline">[docs]</a><span class="k">class</span> <span class="nc">InferencePipeline</span><span class="p">(</span><span class="n">FullImageInferencePipelineBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pipeline class for model for whole image inference on ct-images.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the model output is expected to be a valid probability distribution</span>
    <span class="n">MODEL_OUTPUT_POSTERIOR_RANGE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="InferencePipeline.Variables"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipeline.Variables">[docs]</a>    <span class="k">class</span> <span class="nc">Variables</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Variables associated with the inference pipeline</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># an instantiated model to use for inference.</span>
        <span class="n">Model</span> <span class="o">=</span> <span class="s1">&#39;model&#39;</span>
        <span class="c1"># the configuration associated with the model.</span>
        <span class="n">ModelConfig</span> <span class="o">=</span> <span class="s1">&#39;model_config&#39;</span>
        <span class="c1"># the shape of the image required as output from the pipeline.</span>
        <span class="n">OutputImageShape</span> <span class="o">=</span> <span class="s1">&#39;output_image_shape&#39;</span>
        <span class="c1"># A Tuple[int,int,int] with the crop size that should be used. For large images, this will be</span>
        <span class="c1"># the test_crop_size from the model config, but for smaller images, it will be the componentwise</span>
        <span class="c1"># minimum of test_crop_size and image_size</span>
        <span class="n">CropSize</span> <span class="o">=</span> <span class="s1">&#39;crop_size&#39;</span>
        <span class="c1"># The stride size to use, possibly adjusted for small images (see above for crop_size)</span>
        <span class="n">Stride</span> <span class="o">=</span> <span class="s1">&#39;stride&#39;</span>
        <span class="c1"># The size of the output tensor that the model will produce when fed with an input tensor that</span>
        <span class="c1"># has the given crop_size.</span>
        <span class="n">OutputSize</span> <span class="o">=</span> <span class="s1">&#39;output_size&#39;</span></div>

<div class="viewcode-block" id="InferencePipeline.Result"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipeline.Result">[docs]</a>    <span class="k">class</span> <span class="nc">Result</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Contains the inference results from a single pass of the inference pipeline</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">patient_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">segmentation</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">posteriors</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">voxel_spacing_mm</span><span class="p">:</span> <span class="n">TupleFloat3</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            :param patient_id: The id of the patient instance for with inference is being performed on.</span>
<span class="sd">            :param segmentation: Z x Y x X (argmaxed over the posteriors in the class dimension)</span>
<span class="sd">            :param voxel_spacing_mm: Voxel spacing to use for each dimension in (Z x Y x X) order</span>
<span class="sd">            :param posteriors: Class x Z x Y x X</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">patient_id</span> <span class="o">=</span> <span class="n">patient_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span> <span class="o">=</span> <span class="n">segmentation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">posteriors</span> <span class="o">=</span> <span class="n">posteriors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">voxel_spacing_mm</span> <span class="o">=</span> <span class="n">voxel_spacing_mm</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxel_spacing_mm</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;voxel_spacing_mm must have length 3, found: </span><span class="si">{</span><span class="n">voxel_spacing_mm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxel_spacing_mm</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;voxel_spacing_mm must have values &gt; 0 in each dimension, found: </span><span class="si">{</span><span class="n">voxel_spacing_mm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">ml_util</span><span class="o">.</span><span class="n">check_size_matches</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">posteriors</span><span class="p">,</span>
                                       <span class="n">dim1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                       <span class="n">dim2</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                       <span class="n">matching_dimensions</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">arg1_name</span><span class="o">=</span><span class="s2">&quot;segmentation&quot;</span><span class="p">,</span>
                                       <span class="n">arg2_name</span><span class="o">=</span><span class="s2">&quot;posteriors&quot;</span><span class="p">)</span>

            <span class="n">segmentation_value_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">posteriors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segmentation_value_range</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values in the segmentation map must be in range [0, classes), &quot;</span>
                                <span class="s2">&quot;found classes:</span><span class="si">{}</span><span class="s2">, segmentation range:</span><span class="si">{}</span><span class="s2">&quot;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">posteriors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segmentation_value_range</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_uncertainty</span> <span class="o">=</span> <span class="n">compute_uncertainty_map_from_posteriors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">posteriors</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uncertainty</span>

<div class="viewcode-block" id="InferencePipeline.Result.with_new_segmentation"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipeline.Result.with_new_segmentation">[docs]</a>        <span class="k">def</span> <span class="nf">with_new_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segmentation</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempt to replace segmentation of shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;with one of shape </span><span class="si">{</span><span class="n">segmentation</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">(</span>
                <span class="n">patient_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">patient_id</span><span class="p">,</span>
                <span class="n">segmentation</span><span class="o">=</span><span class="n">segmentation</span><span class="p">,</span>
                <span class="n">posteriors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">posteriors</span><span class="p">,</span>
                <span class="n">voxel_spacing_mm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">voxel_spacing_mm</span><span class="p">)</span></div></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">SegmentationLightning</span><span class="p">,</span> <span class="n">model_config</span><span class="p">:</span> <span class="n">config</span><span class="o">.</span><span class="n">SegmentationModelBase</span><span class="p">,</span>
                 <span class="n">pipeline_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model_config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_id</span> <span class="o">=</span> <span class="n">pipeline_id</span>

<div class="viewcode-block" id="InferencePipeline.create_from_checkpoint"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipeline.create_from_checkpoint">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_from_checkpoint</span><span class="p">(</span><span class="n">path_to_checkpoint</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
                               <span class="n">model_config</span><span class="p">:</span> <span class="n">SegmentationModelBase</span><span class="p">,</span>
                               <span class="n">pipeline_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InferencePipeline</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an instance of the inference pipeline for a given epoch from a stored checkpoint.</span>
<span class="sd">        After loading, the model parameters are checked for NaN and Infinity values.</span>
<span class="sd">        If there is no checkpoint file for the given epoch, return None.</span>
<span class="sd">        :param path_to_checkpoint: The path to the checkpoint that we want to load</span>
<span class="sd">        model_config.checkpoint_folder</span>
<span class="sd">        :param model_config: Model related configurations.</span>
<span class="sd">        :param pipeline_id: Numeric identifier for the pipeline (useful for logging when ensembling)</span>
<span class="sd">        :return InferencePipeline: an instantiated inference pipeline instance, or None if there was no checkpoint</span>
<span class="sd">        file for this epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path_to_checkpoint</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="c1"># not raising a value error here: This is used to create individual pipelines for ensembles,</span>
            <span class="c1">#                                   possible one model cannot be created but others can</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not recover model from checkpoint path </span><span class="si">{</span><span class="n">path_to_checkpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">lightning_model</span> <span class="o">=</span> <span class="n">load_from_checkpoint_and_adjust_for_inference</span><span class="p">(</span><span class="n">model_config</span><span class="p">,</span> <span class="n">path_to_checkpoint</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lightning_model</span><span class="p">,</span> <span class="n">SegmentationLightning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">InferencePipeline</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">lightning_model</span><span class="p">,</span> <span class="n">model_config</span><span class="o">=</span><span class="n">model_config</span><span class="p">,</span> <span class="n">pipeline_id</span><span class="o">=</span><span class="n">pipeline_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="InferencePipeline.post_process_posteriors"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipeline.post_process_posteriors">[docs]</a>    <span class="k">def</span> <span class="nf">post_process_posteriors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posteriors</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform post processing on the computed outputs of the a single pass of the pipelines.</span>
<span class="sd">        Currently the following operations are performed:</span>
<span class="sd">        -------------------------------------------------------------------------------------</span>
<span class="sd">        1) the mask is applied to the posteriors (if required).</span>
<span class="sd">        2) the final posteriors are used to perform an argmax to generate a multi-label segmentation.</span>
<span class="sd">        3) extract the largest foreground connected component in the segmentation if required</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">posteriors</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">apply_mask_to_posteriors</span><span class="p">(</span><span class="n">posteriors</span><span class="o">=</span><span class="n">posteriors</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># create segmentation using an argmax over the posterior probabilities</span>
        <span class="n">segmentation</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">posteriors_to_segmentation</span><span class="p">(</span><span class="n">posteriors</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">posteriors</span><span class="p">,</span> <span class="n">segmentation</span></div>

<div class="viewcode-block" id="InferencePipeline.predict_whole_image"><a class="viewcode-back" href="../../../../rst/api/ML/pipelines.html#InnerEye.ML.pipelines.inference.InferencePipeline.predict_whole_image">[docs]</a>    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">predict_whole_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_channels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">voxel_spacing_mm</span><span class="p">:</span> <span class="n">TupleFloat3</span><span class="p">,</span>
                            <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">patient_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a single inference pass through the pipeline for the provided image</span>

<span class="sd">        :param image_channels: The input image channels to perform inference on in format: Channels x Z x Y x X.</span>
<span class="sd">        :param voxel_spacing_mm: Voxel spacing to use for each dimension in (Z x Y x X) order</span>
<span class="sd">        :param mask: A binary image used to ignore results outside it in format: Z x Y x X.</span>
<span class="sd">        :param patient_id: The identifier of the patient this image belongs to (defaults to 0 if None provided).</span>
<span class="sd">        :return InferenceResult: that contains Segmentation for each of the classes and their posterior probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">empty_cache</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">image_channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;image_channels cannot be None&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image_channels</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;image_channels must be in shape: Channels x Z x Y x X&quot;</span>
                                      <span class="s2">&quot;found image_channels shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">image_channels</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ml_util</span><span class="o">.</span><span class="n">check_size_matches</span><span class="p">(</span><span class="n">image_channels</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">ScalarImage</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">image_channels</span><span class="p">)</span>
        <span class="n">INPUT</span> <span class="o">=</span> <span class="s1">&#39;input_image&#39;</span>
        <span class="n">MASK</span> <span class="o">=</span> <span class="s1">&#39;mask&#39;</span>

        <span class="n">subject_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tio</span><span class="o">.</span><span class="n">Image</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">INPUT</span><span class="p">:</span> <span class="n">image</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subject_dict</span><span class="p">[</span><span class="n">MASK</span><span class="p">]</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">LabelMap</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">subject</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">Subject</span><span class="p">(</span><span class="n">subject_dict</span><span class="p">)</span>

        <span class="n">constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">crop_size_constraints</span>

        <span class="c1"># Make sure the image size is compatible with the model</span>
        <span class="n">multiple_constraints</span> <span class="o">=</span> <span class="n">constraints</span><span class="o">.</span><span class="n">multiple_of</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="n">multiple_constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ensure_shape_multiple</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">EnsureShapeMultiple</span><span class="p">(</span><span class="n">constraints</span><span class="o">.</span><span class="n">multiple_of</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">subject</span> <span class="o">=</span> <span class="n">ensure_shape_multiple</span><span class="p">(</span><span class="n">subject</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># There may be cases where the test image is smaller than the test_crop_size. Adjust crop_size</span>
        <span class="c1"># to always fit into image. If test_crop_size is smaller than the image, crop will remain unchanged.</span>
        <span class="n">restrict_patch_size</span> <span class="o">=</span> <span class="n">constraints</span><span class="o">.</span><span class="n">restrict_crop_size_to_image</span>  <span class="c1"># type: ignore</span>
        <span class="n">effective_patch_size</span><span class="p">,</span> <span class="n">effective_stride</span> <span class="o">=</span> <span class="n">restrict_patch_size</span><span class="p">(</span><span class="n">subject</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">test_crop_size</span><span class="p">,</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">inference_stride_size</span><span class="p">)</span>

        <span class="n">patch_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">effective_patch_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">effective_stride</span><span class="p">)</span>
        <span class="n">grid_sampler</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">GridSampler</span><span class="p">(</span>
            <span class="n">subject</span><span class="p">,</span>
            <span class="n">effective_patch_size</span><span class="p">,</span>
            <span class="n">patch_overlap</span><span class="p">,</span>
            <span class="n">padding_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">inference_batch_size</span>
        <span class="n">patch_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">grid_sampler</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">aggregator</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">GridAggregator</span><span class="p">(</span><span class="n">grid_sampler</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Inference on image size </span><span class="si">{</span><span class="n">subject</span><span class="o">.</span><span class="n">spatial_shape</span><span class="si">}</span><span class="s2"> will run &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;with crop size </span><span class="si">{</span><span class="n">effective_patch_size</span><span class="si">}</span><span class="s2"> and stride </span><span class="si">{</span><span class="n">effective_stride</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">patches_batch</span> <span class="ow">in</span> <span class="n">patch_loader</span><span class="p">:</span>
            <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">patches_batch</span><span class="p">[</span><span class="n">INPUT</span><span class="p">][</span><span class="n">tio</span><span class="o">.</span><span class="n">DATA</span><span class="p">]</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_config</span><span class="o">.</span><span class="n">use_gpu</span><span class="p">:</span>
                <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">input_tensor</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
            <span class="n">locations</span> <span class="o">=</span> <span class="n">patches_batch</span><span class="p">[</span><span class="n">tio</span><span class="o">.</span><span class="n">LOCATION</span><span class="p">]</span>
            <span class="c1"># perform the forward pass</span>
            <span class="n">patches_posteriors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="c1"># pad posteriors if they are smaller than the input</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">input_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
            <span class="n">patches_posteriors_shape</span> <span class="o">=</span> <span class="n">patches_posteriors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">input_shape</span> <span class="o">!=</span> <span class="n">patches_posteriors_shape</span><span class="p">:</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">patches_posteriors_shape</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">difference</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># the differences in shape are expected to be even</span>
                <span class="n">padding</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">difference</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">patches_posteriors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">patches_posteriors</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>
            <span class="c1"># collect the predictions over each of the batches</span>
            <span class="n">aggregator</span><span class="o">.</span><span class="n">add_batch</span><span class="p">(</span><span class="n">patches_posteriors</span><span class="p">,</span> <span class="n">locations</span><span class="p">)</span>
        <span class="n">posteriors</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">get_output_tensor</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">posteriors_mask</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">subject</span><span class="p">[</span><span class="n">MASK</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">posteriors</span><span class="p">,</span> <span class="n">segmentation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_process_posteriors</span><span class="p">(</span><span class="n">posteriors</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">posteriors_mask</span><span class="p">)</span>

        <span class="n">image_util</span><span class="o">.</span><span class="n">check_array_range</span><span class="p">(</span><span class="n">posteriors</span><span class="p">,</span> <span class="n">error_prefix</span><span class="o">=</span><span class="s2">&quot;Whole image posteriors&quot;</span><span class="p">)</span>

        <span class="c1"># Make sure the final shape matches the input shape by undoing the padding in EnsureShapeMultiple (if any)</span>
        <span class="n">posteriors_image</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">ScalarImage</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">posteriors</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">segmentation_image</span> <span class="o">=</span> <span class="n">tio</span><span class="o">.</span><span class="n">LabelMap</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">segmentation</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">affine</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">subject</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">posteriors_image</span><span class="p">,</span> <span class="s1">&#39;posteriors&#39;</span><span class="p">)</span>
        <span class="n">subject</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">segmentation_image</span><span class="p">,</span> <span class="s1">&#39;segmentation&#39;</span><span class="p">)</span>
        <span class="c1"># Remove some images to avoid unnecessary computations</span>
        <span class="n">subject</span><span class="o">.</span><span class="n">remove_image</span><span class="p">(</span><span class="n">INPUT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subject</span><span class="o">.</span><span class="n">remove_image</span><span class="p">(</span><span class="n">MASK</span><span class="p">)</span>
        <span class="n">subject_original_space</span> <span class="o">=</span> <span class="n">subject</span><span class="o">.</span><span class="n">apply_inverse_transform</span><span class="p">()</span> <span class="k">if</span> <span class="n">subject</span><span class="o">.</span><span class="n">applied_transforms</span> <span class="k">else</span> <span class="n">subject</span>
        <span class="n">posteriors</span> <span class="o">=</span> <span class="n">subject_original_space</span><span class="o">.</span><span class="n">posteriors</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
        <span class="n">segmentation</span> <span class="o">=</span> <span class="n">subject_original_space</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># prepare pipeline results from the processed batch</span>
        <span class="k">return</span> <span class="n">InferencePipeline</span><span class="o">.</span><span class="n">Result</span><span class="p">(</span>
            <span class="n">patient_id</span><span class="o">=</span><span class="n">patient_id</span><span class="p">,</span>
            <span class="n">segmentation</span><span class="o">=</span><span class="n">segmentation</span><span class="p">,</span>
            <span class="n">posteriors</span><span class="o">=</span><span class="n">posteriors</span><span class="p">,</span>
            <span class="n">voxel_spacing_mm</span><span class="o">=</span><span class="n">voxel_spacing_mm</span>
        <span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Microsoft Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>